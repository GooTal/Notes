# 2022全国大学生系统能力大赛操作系统设计赛技术培训会（第四场）笔记--夏虞斌老师--《操作系统教学与科研》

视频播放地址：[2022全国大学生系统能力大赛操作系统设计赛技术培训会-哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Za41177L2?spm_id_from=333.999.0.0&vd_source=c0ebc331ee63978f26b2050109cc5826)。

书和在线课程：[《现代操作系统 原理与实现》](https://ipads.se.sjtu.edu.cn/mospi/)。

 [ipads实验室的github网页](https://github.com/Penglai-Enclave)

**linux可插拔的机制放在用户态，和微内核非常类似。**

**操作系统研究受到上层应用和底层硬件双重驱动**

* 互联网、网络搜索、大数据、人工智能、智能驾驶、云计算等
* 持久性内存、GPU、智能网卡、Al芯片、硬件Enclave等

**两个核心问题**

* 如何为上层应用提供更快、更安全、更易用的接口？
* 如何为底层硬件建立高效、安全、高利用率的抽象?

## 异构操作系统

### 挑战-1∶需要同时支持多种指令集(ISA)

不同的计算单元可能使用不同的指令集

**思路**：两阶段编译解决异构ISA问题

* 阶段1∶从源码编详得到一个中间表示(IR)，分发IR给使用者
* 阶段2∶当决定在具体的平台上运行时，将IR生成binary，根据具体部署的计算节点编译出不同指令集的二进制。

### 挑战-2：内核/应用在跨总线的环境下的同步和通信

异构硬件间通过多种总线连接，无共享内存和缓存一致性

**思路**：多内核抽象——每个设备运行一个monitor。 OS也被拆分到不同设备上的monitor中，类似MultiKernel

* CPU上负责OS进程管理
* Memory monitor上负责OS内存管理
* 通过RDMA等快速网络通信

### 挑战-3：CPU提供OS服务容易成为系统性能瓶颈

各种加速器等异构计算单元依赖于CPU提供OS服务

* 以CPU为中心的OS服务︰需要两次拷贝，性能开销大
* 以加速器为中心的OS服务∶加速器不适合执行如网络协议栈等OS服务

**思路**:CPU负责控制流，加速器负责数据流

* 解耦数据流和控制流 类似于DMA
  * 控制流由CPU负责
  * 数据流由异构加速器负责
  * 避免OS成为性能瓶颈

### 其他挑战与待解决的问题

* 跨计算节点的通信通常使用PCle，性能较差，如何优化?
* 如何将OS的服务以及应用程序分布在不同的计算节点?
* 异构硬件非常多样，OS需要为应用提供怎样的抽象?
* 如何支持跨ISA的应用程序迁移? <font color="red">例如seL4微内核的LoongArch移植 </font>
* 智能I/O设备上的计算单元容易出现Failure，如何容错?
* 如何调度和共享各种异构设备给不同用户/应用使用?
* 异构系统的安全性如何保证?

## 新的应用接口

极低时延应用对操作系统的新要求

随着网络时延降低，OS提供的服务和抽象成了瓶颈。OS如何重新设计？

### 挑战-1∶内核软件栈臃肿

内核软件栈涉及系统调用、内存管理、命名管理等开销，成为了性能瓶颈

**思路**：通过内核旁路解决软件栈臃肿问题。

* 机遇：新型硬件设备具备虚拟化能力。如一张网卡（NIC)可以虚拟为多张虚拟网卡( vNIC )
* 核心思想：操作系统将虚拟设备直接交给应用使
  用
* 应用可以直接访问设备，无需经过内核软件栈，大幅降
  低时延

**潜在问题**：

* 设备映射过于死板，可能出现负载不均衡/资源浪费

* 应用直接访问设备，可能存在安全问题

* 生态碎片化

**可能的解决思路**：

* 支持任务偷窃机制，均衡负载
* 引入硬件保护机制

### 挑战-2∶内核抽象过于笨重

Linux内核代码逐年递增，极大影响了虚拟机的启动效率。

虚拟机监控器(如Xen)在启动过程中引入了过大的软件开销。

**思路**：通过轻量级与定制化内核提高性能

* 核心思想:只保留与应用相关的功能
  - Unikernel:专为应用定制的特化内核。uni英文意为单一的。
  - LightVM:移除VM启动过程中不需要的部分，实现微秒级启动

### 挑战-3∶应用缺乏对于调度的控制

调度一定会进入内核，造成微秒级开销

* 进程调度的开销是用户态线程调度开销的2倍

内核缺乏应用语义，可能无法做出最好的调度决策。微内核更缺乏用户态信息，可能更难做出决策。

调度要做页表切换等工作，要进内核。

**思路**：让应用做更多决策，如自主调度

* 例如:将物理CPU核直接交给应用
  * 应用使用核与内核交互，而不是线程
  * 避免内核调度器与应用调度策略冲突造成的“双调度问题”
* 以内核线程的形式将物理核交给应用，用户态线程可自主调度
* 免除调度开销使应用具有了更好的可扩展性
* 这样避免了上下文切换，尤其是内核到用户态切换的开销，<font color="red">为什么？ </font>，以内核线程的形式将物理核交给应用，是不是相当于应用运行在内核态？

### 更多:设计新型操作系统的关键词
* 放权
  * 将内核从应用的关键路径上移除，绕开臃肿的软件栈
  * 将更多功能（如调度）交由应用完成，减少进入内核的次数
* 裁剪
  * 只保留内核抽象的必需功能，最小化抽象带来的开销

## 多核同步原语

### 挑战-1: CPU核越来越多，锁的可扩展性遇到瓶颈

12个核还可以，到32个核就不太行，大量时间浪费在了多核同步上

MCS Lock、Cohort Lock等都很难做到numa环境下性能的提升。

**思路**：将所有竞争者的临界区集中到一个核上处理

* 把所有临界区跑在一个核上，这个核专门做同步，其他核向其请求并接受返回值。

* 利用batch思想进一步优化。

**迁移锁不是多核锁的终极解决方案。**

* 问题-1︰适应性--逻辑复杂、单独的锁服务器使得迁移锁在低竞争程度时开销巨大

* 问题-2∶易用性--锁暴露的接口发生改变，无法直接使用在现有系统中

**除了性能可扩展性与易用性之外的挑战**

* 挑战#2∶如何在提升性能的同时，维持锁的易用性?
  避免改变锁的语义，以及对应用进行修改
* 挑战l#3∶新的硬件会给同步带来什么样的影响?
  异构系统不同设备之间如何同步/通讯?
  采用弱内存模型的处理器如何耗费最小开销保证正确性?
* 挑战#4∶同步原语能否和操作系统其他模块更好的协作?
  如调度器，以维持调度公平;或避免调度在忙等的线程提升性能。

## 持久性内存(PM)

持久性内存正在变得越来越流行

* 新型的内存/存储设备，非易失性内存(NVM)

* 结合内存与存储各自的特点
  * 性能与DRAM接近，高于SSD等等等等

### 挑战-1∶操作系统该如何为持久内存提供抽象?

**思路**：直接将持久性内存当做存储设备管理

* 使用内核文件系统管理持久内存
  * 优势︰对应用透明（复用FS的接口)
  * 问题：持久内存持久化粒度为字节（缓存行)
  * 如何保证崩溃一致性？回想讲过的崩溃一致性方法
* 新的挑战:持久性内存远快于硬盘，内核成为新的瓶颈
  * 之前文件系统瓶颈在于硬盘访问速度

### 挑战-2∶如何避免内核带来的开销

* 发现:持久性内存可以在用户态访问
  * 硬盘是I/O设备，必须由内核统一管理
  * 内存则本来就是用户态可以访问的
* 思路:将FS功能移到用户态，从而避免进入内核
  * 即kernel bypassing
* 新挑战:如何保障数据安全性和隔离性?
  * 例如∶若inode可以由用户直接访问，会发生什么?
  * 想法:需要用户态和内核态进行分工

**思路-1**:用户FS记录日志，内核FS整理日志

* 写操作
  * 用户态FS只能（只需)在Per-process的NVM空间中记录日志
  * 内核FS定期查看日志，并将数据更新到全局位置
  * 在应用写完后，内核整理前，新的内容全局不可见
* 读操作
  * 经过内核FS检查后，用户态FS可以直接读取NVM部分区域
* 优势
  * 用户FS只需记录NVM日志即可保证操作完成
* 问题:需要定期去进行整理，多进程同步、写放大问题

**思路-2**∶用户FS处理数据，内核FS管理元数据

* 元数据安全是安全与隔离的关键问题
  * 用户FS将文件mmap 到用户态后，直接在用户态处理数据请求
  * 内核FS只负责处理文件的元数据操作
* 优势
  * 数据修改只需写入一次，且无需内核参与
  * 元数据的安全和一致由内核保证
* 问题:文件元数据依然需要内核的参与
  * 元数据操作本身较快，因此进出内核时间占比更大

**思路-3**∶用户FS处理请求，内核FS提供隔离

* 发现:相同权限的文件具有聚集性
  * 在验证权限后，用户FS 能够处理相同权限文件上的所有请求
  * 内核FS只提供权限验证、粗粒度空间管理和强隔离保障
  * 读写权限控制由页表实现（别忘了PM是内存!)
* 优势
  * 文件操作基本不需要内核参与，包括数据和元数据
  * 文件权限和隔离性被内核进行保障
* 问题:权限相关的操作需要内核处理

**未来:PM上是否还需要文件系统?**

* 在持久性内存的场景下，是否还需要FS 进行管理?

  * 命名( naming )问题谁来处理?
  * 管理员如何对存储进行维护?

* 除了FS接口之外，是否有更好的(存储）编程抽象?

  * 持久性内存大量使用mmap()接口

  - ioctl被使用的越来越频繁
  - 标准文件接口以及POSIX标准是否已经过时?

## 智能网卡

背景:智能网卡的兴起
摩尔定律逐渐失效

* 处理器频率和核数难以大幅度提升
* 网卡速度稳步提升:处理器速度难以跟随网络速度进一步提升

智能网卡的方案

* 允许将一部分软件功能卸载至智能网卡之中
  * 卸载的软件可直接处理网络数据，减少与Host处理器交互

研究思路:思考将何种功能或应用卸载至设备

### 挑战:OS如何使用智能网卡优化网络应用?

方向一:卸载部分应用逻辑

- KV-Direct (SOSP'17),NetCache (SOSP'17)
- NICA(ATC'19),E3(ATC'19), iPipe (SIGCOMM'19)

方向二:卸载操作系统功能

* 卸载网络虚拟化功能(NSDI'18)
* 卸载部分网络协议栈功能: AccelTCP (NSDI20)

## 系统安全隔离

系统隔离的演变：层次化到“**九宫格**”

旧的模式：

* 自底向上权限由高到低，信任同样由高到低，隔离面为单向
* 越底层，漏洞危害越大

新的方向：

* 隔离面由单向变为双向，信任与权限解耦
* 每层内部细粒度隔离
* 隔离支撑模块：硬件原语支持更高层次语义
* 软硬结合成为趋势，**软硬协同**

## 操作系统新型测试方法

操作系统测试面临的挑战

* 现有的测试方法
  * 静态:在不运行代码前提下，通过语法、控制流等分析代码异常
  * 动态:运行测试程序，判断执行是否符合预期
  * 近年来动态测试工作较多
  * 怎么去测试更好？
* 动态测试的挑战
  * 如何构造有效的测试样例
  * 测试中如何判定出现异常
  * 如何有效地复现BUG

## 形式化证明

**“形式化证明是已知唯一一个保证软件没有编程错误的手段”**

形式化证明的案例

* 操作系统

  - seL4，首个形式化验证的微内核，SOSP'09最佳论文-

  - CertikOS，耶鲁大学开发的支持并发的内核[OSDI'16]

* 文件系统

  - FScQ，具有崩溃安全性的串行文件系统[SOSP'15]-

  - AtomFS，接口具有原子性的并发文件系统[SOSP'19]。

* 分布式协议

  * Amazon，广泛应用TLA+用于保障软件协议设计的正确性
  * 证明分布式共识协议Paxos与Raft联系与优化迁移[PODC'19]

## 总结

*  oS的概念往往缺乏精确的定义，可以用导出的方法
  * 场景先行，问题驱动，步步推导，概念最少
* "自然导出"教学的三个步骤
  * 程序员视角（直观感受，理解需求)
  * 相关硬件（原材料)
  * 实现者角度（数据结构+接口)
* 以真实系统作为案例分析
  * 如Linux，或其他操作系统;如有多种实现，可增加横向对比。
* 以问题作为引导，启发思考
  * 系统性思维，充分思考某个概念或技术的适用范围







